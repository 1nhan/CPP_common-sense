----------------------------------------------------------------

# C5 Writing programming

의사코드(pseudo code) : 
설계 초기에 표기법의 정확한 의미가 아직 확실하지 않을 때 의사코드를 사용하곤 한다.

```text
while (not_finished) {
    read_a_line
    calculate // 처리 수행
    write_result
}
```
----------------------------------------------------------------


[토큰(token)](https://learn.microsoft.com/ko-kr/cpp/cpp/character-sets?view=msvc-170) : 은 숫자나 연산자처럼 우리가 한 단위(unit)로 간주하는 문자들의 연속이다. 
어떤 형태로든 “토큰화”는 텍스트 분석(text analysis)이 시작되는 일반적인 방식이다.
토큰을 (kind,value) 쌍으로 나타내는 것

----------------------------------------------------------------

멤버 접근 표기(member access notation, 멤버 접근 표기)는 다음과 같다: 
object_name.member_name

----------------------------------------------------------------

토큰(Token)은 C++ 사용자 정의 타입(user-defined type)의 예이다. 
사용자 정의 타입은 데이터 멤버(data members)뿐만 아니라 
멤버 함수(member functions, operations)를 가질 수 있다.

----------------------------------------------------------------

토큰(Token)을 초기화(construct)할 수 있다. 예를 들면:

```cpp
Token t1 {'+'};         // t1.kind = '+'
Token t2 {'8', 11.5};   // t2.kind = '8'이고 t2.value = 11.5
Token t3;               // 오류: 초기자(initializer) 누락
```

----------------------------------------------------------------
토큰 사용하기(Using tokens)

```cpp
Token get_token();
vector <Token>tok;

int main(void)
{
    while(cin)
    {
        Token t = get_token();
        tok.push_back(t);_
    }

return 0;
}
```

----------------------------------------------------------------

곱셈 연산 찾기(Finding multiply)

```cpp

for(int i =0; i<tok.size(); ++i){
    if(tok[i].kind=="*"){   
    double d = tok[i-1].value*tok[i+1].value};
    }
}
```
----------------------------------------------------------------

초기에는 기능 확장(feature creep)을 피하고 필수 기능만 구현한 단순한 버전을 먼저 만드는 것이 중요하다. 

----------------------------------------------------------------


문법에 따라 토큰의 흐름을 읽는 것을 파싱(parsing)이라 하며, 
이를 수행하는 프로그램은 일반적으로 파서(parser) 
                            또는 구문 분석기(syntax analyzer)라 불린다. 
문법을 표현하고 이에 대한 파서를 작성하는 방법에 관한 전문 서적도 존재하며, 
문법으로부터 파서를 생성하는 파서 생성기(parser generator)라는 프로그램도 있다.

----------------------------------------------------------------

문법을 어떻게 읽을까? 
기본적으로 어떤 입력이 주어지면, 
우리는 “최상위 규칙(top rule)”인 Expression부터 시작하여, 
읽은 토큰에 맞는 규칙을 찾아간다. 
이러한 전략을 상향식(top-down) 접근이라 한다. 
<br>
반대로, 먼저 토큰을 보고 어떤 문법 규칙이 적용될 수 있을지를 판단한 뒤, 
다음 토큰을 확인하면서 가능한 규칙을 좁혀가는 방식도 있다. 
이는 하향식(bottom-up) 접근이라 한다.

----------------------------------------------------------------

재귀(recursion)란 함수가 자기 자신을 호출하는 것을 의미한다. 
모든 재귀가 무한인 것은 아니며, 재귀는 매우 유용한 프로그래밍 기법이다

----------------------------------------------------------------

[switch 명령문](https://learn.microsoft.com/ko-kr/cpp/cpp/switch-statement-cpp?view=msvc-170 "switch 문") 본문은 일련의 case 레이블과 선택적 default 레이블로 구성됩니다.
default 레이블은 한 번만 나타날 수 있습니다. 
default 문은 종종 끝에 배치되지만 switch 문 본문의 아무 곳에나 나타날 수 있습니다. 
case 또는 default 레이블은 switch 문 안에만 나타날 수 있습니다.


----------------------------------------------------------------

#### 오류
&nbsp;↳컴파일 타임 오류(Compile-time errors) <br>
&emsp;↳ 문법 오류(Syntax errors) <br>
&emsp;↳ 타입 오류(Type errors) <br>
&nbsp;↳링크 타임 오류(Link-time errors) <br>
&nbsp;↳런타임 오류(Run-time errors)  <br>
&emsp;↳ 컴퓨터(하드웨어 또는 운영체제)가 감지한 오류 <br>
&emsp;↳ 라이브러리(예: 표준 라이브러리)가 감지한 오류 <br>
&emsp;↳ 사용자 코드가 감지한 오류 = 논리 오류(Logic errors) <br>

----------------------------------------------------------------

컴파일 타임 오류(Compile-time errors) : 코드를 실제로 생성하기 전에, 
컴파일러는 코드를 분석하여 문법 오류(syntax errors)와 타입 오류(type errors)를 감지합니다.
프로그램이 언어 명세(language specification)를 충족한다고 판단될 때에만 
컴파일러는 다음 단계로 진행을 허용합니다.<br>

문법 오류(syntax error) : C++ 문법에 따라 올바르게 작성되지 않았기 때문에, 
컴파일러는 이를 거부(reject)합니다. 대개 사소한 실수임에도 불구하고, 
컴파일러의 오류 메시지는 난해하고(cryptic) 때로는 프로그램의 다른 줄을 참조하기도 합니다.<br>

타입 오류(type error) : 변수나 함수 등에 대해 선언한 타입(또는 선언하지 않은 경우)과 
그에 대해 대입하거나 함수 인자로 전달하는 값의 타입이 일치하지 않을 때 발생합니다.<br>


링크 타임 오류(Link-time errors) : <br>
모든 함수는 다음 두 가지 규칙을 반드시 따라야 합니다:<br>
 1. 프로그램 내에서 사용되는 모든 변환 단위에서 해당 함수는 정확히 동일한 타입(type)으로 
선언(declaration)되어야 합니다.<br>
 2. 해당 함수는 프로그램 전체에서 정확히 한 번만 정의(definition)되어야 합니다.<br>
이 중 하나라도 위반되면, 링커(linker)는 오류를 발생시킵니다.<br>

런타임 오류(Run-time errors) : <br>
프로그램의 논리적 구조에 대한 이해가 부족했거나<br>
여러분이 작성했다고 생각한 코드가 실제로는 다르게 작성되었거나<br>
if 문 등에서 사소한 실수(silly error)를 저질렀거나<br>
이러한 논리 오류(logic error)는 대개 가장 찾기 어렵고 제거하기 까다로운 오류입니다.


----------------------------------------------------------------

프로그램에서 발생할 수 있는 오류의 주요 원천<br>
&emsp;&emsp;↳ 부정확하거나 부실한 사양, 명세(Poor specification)<br>
&emsp;&emsp;↳ 불완전한 프로그램(Incomplete programs)<br>
&emsp;&emsp;↳ 예상치 못한 인자(Unexpected arguments)<br>
&emsp;&emsp;↳ 예상치 못한 입력(Unexpected input)<br>
&emsp;&emsp;↳ 예상치 못한 상태(Unexpected state)<br>
&emsp;&emsp;↳ 논리 오류(Logical errors)

----------------------------------------------------------------

피호출자 검사(callee checks):<br>
“함수 자체가 인자를 검사해야 한다”는 방식, 
호출된 함수(called function)를 피호출자(callee)라고 부르기 때문입니다.<br>

----------------------------------------------------------------

___함수 내부에서 인자 검사가 항상 좋은가?___<br>
___함수 내부에서 인자를 검사하는 것이 이렇게 간단한데, 왜 모든 사람이 항상 그렇게 하지 않을까요?___<br>

__1. 함수 정의를 수정할 수 없는 경우__<br>
해당 함수가 라이브러리 함수일 수 있음<br>
다른 사용자들이 오류 처리 기준을 공유하지 않을 수 있음<br>
소스 코드가 없거나, 라이브러리가 자주 업데이트되므로, 수정한 내용을 매번 다시 적용해야 하는 부담이 있음<br>
__2. 피호출자가 오류 발생 시 무엇을 해야 할지 모르는 경우__<br>
특히 라이브러리 함수에서 흔한 상황<br>
라이브러리 작성자는 오류를 감지할 수 있지만, 오류 발생 시 어떤 행동을 취해야 하는지는 호출자만 알고 있음<br>
__3. 피호출자가 어디서 호출되었는지 모르는 경우__<br>
오류 메시지는 문제가 발생했음을 알려줄 뿐, 어떻게 그 지점에 도달했는지는 알려주지 않음<br>
때로는 더 구체적인 오류 메시지가 필요함<br>
__4. 성능 문제(Performance)__<br>
작은 함수에서는 검사 비용이 계산 비용보다 클 수 있음<br>
예: area() 함수의 경우 검사 코드가 함수의 크기를 두 배 이상 증가시킴 즉, 
실행해야 할 기계 명령어(machine instructions)의 수가 늘어남<br>
특히 함수들이 서로 호출하며 같은 정보를 반복적으로 검사하는 경우 성능에 치명적일 수 있음<br><br>
___결론: 특별한 이유가 없다면, 함수 내부에서 인자 검사를 수행하라.___<br>

----------------------------------------------------------------

인자(argument)를 검사한 결과 오류가 발견되었다면, 그 다음엔 무엇을 해야 할까?<br>
“오류 값(error value)”을 반환하는 방식<br>

----------------------------------------------------------------

___예외 처리의 핵심 아이디어___<br>
오류의 감지(detection)는 피호출자(called function)가 수행하고,<br>
오류의 처리(handling)는 호출자(calling function)가 수행하며,<br>
감지된 오류가 무시되지 않도록 보장하는 것<br><br>
>기본 개념<br>
> 함수가 처리할 수 없는 오류를 발견했을 때, 또는 즉시 상위 호출자가 처리할 수 있을 것이라 
기대할 수 없을 때, 해당 함수는 정상적으로 반환하지 않고,  예외를 던진다.(throw)<br>
> 예외는 무엇이 잘못되었는지를 나타내는 정보를 포함합니다. 
예외를 던진 함수의 직접 또는 간접 호출자(caller)는 해당 예외를 잡을 수 있다.(catch)<br>
> 즉, 예외가 발생했을 때 어떤 동작을 할지 지정할 수 있다.<br>
> 함수가 예외에 관심을 표현하려면 try 블록(try-block)을 사용해야 하며, 
그 안에 catch 블록(catch part)을 통해 처리하고자 하는 예외의 종류를 명시합니다.<br>
> 만약 어떤 호출자도 예외를 잡지 않으면, 프로그램은 비정상적으로 종료(terminate)됩니다.

----------------------------------------------------------------

___오류 출력: cerr 사용___<br>
오류 메시지 출력에는 cout 대신 cerr를 사용합니다.<br>
cerr는 cout과 동일하게 화면에 출력되지만 오류 출력용으로 설계되어 
더 견고하고(error-resilient) 일부 운영체제에서는 파일 등 다른 대상으로 
리디렉션 가능합니다.<br>
cerr를 사용하면 해당 출력이 오류 관련임을 명확히 문서화할 수 있습니다.

----------------------------------------------------------------

C++에서 흔히 사용하는 범위 표기법(range notation)

```코드
[low : high)
```
low 이상(high 미만)의 인덱스. 즉, low는 포함되고, high는 포함되지 않음

```cpp
i <= v.size()
```
이건 잘못된 조건입니다.  정확한 조건은 i < v.size()여야 합니다. 벡터의 끝을 초과한 접근(out-of-range access)입니다.
<br>
off-by-one error (1 차이 오류)<br>
range error (범위 오류)<br>
bounds error (경계 오류)<br>
모두 벡터의 유효한 인덱스 범위를 벗어난 접근을 의미합니다.

----------------------------------------------------------------

___디버깅(Debugging)___<br>
코드를 작성한 후에는 오류를 찾아내고 제거해야 합니다.
이 과정을 디버깅(debugging)이라 합니다.

디버깅의 핵심 질문<br>
___“내 프로그램이 실제로 제대로 작동하는지 어떻게 알 수 있을까?”___ <br>

___버그가 숨을 수 없도록 설계하라___<br>
디버깅은 코드를 작성하기 전에 이미 시작되어야 합니다. 
코드를 많이 작성한 뒤에 디버깅을 단순화하려고 하면 이미 늦습니다. 
먼저 오류를 어떻게 보고할지 결정하세요.

프로그램을 읽기 쉽게 만들기<br>
주석(Comment)을 잘 작성하세요.<br>
의미 있는 이름을 사용하세요.<br>
일관된 코드 레이아웃을 유지하세요. <br>
코드를 작은 함수로 나누세요. <br>
복잡한 코드 구조를 피하세요.<br>
라이브러리를 적극 활용하세요. <br>
컴파일부터 시작하세요. <br>
불변 조건(invariant)을 검사하세요.(단언문(assertion))<br>

----------------------------------------------------------------

___사전 조건이란?___<br>
함수가 인자에 대해 요구하는 조건을 사전 조건(precondition)이라고 합니다. 
이 조건이 참이어야만 함수가 정상적으로 동작할 수 있습니다.<br>

사전 조건이 위반되었을 때 어떻게 할 것인가?<br>
기본적으로 선택지는 두 가지입니다:<br>
무시한다. → 모든 호출자가 올바른 인자를 줄 것이라 가정하거나 희망한다<br>
검사한다. → 조건을 확인하고, 오류를 보고한다

----------------------------------------------------------------

----------------------------------------------------------------

난수 생성: 엔진과 분포

```cpp
default_random_engine engine; // 가장 단순한 엔진
```

모든 값이 동일한 빈도로 나타난다면 이는 균등 분포(uniform_int_distribution)입니다.
```cpp
uniform_int_distribution<int> dist(1,6); // 원하는 분포
for (int i = 0; i < 10; ++i)
    cout << dist(engine) << ' '; // 엔진을 통해 분포에서 값 추출
```
표준 라이브러리는 다음과 같은 분포도 제공합니다:<br>
normal_distribution: 평균 주변의 변동 모델링<br>
exponential_distribution: 대기 시간 모델링<br><br>
테스트용 데이터 생성<br>
예: (이름, 값) 쌍의 벡터 생성
```cpp
vector<pair<string, int>> generate(int n)
// n개의 랜덤 (이름, 값) 쌍 생성
{
    vector<pair<string, int>> res;
    for (int i = 0; i < n; ++i)
        res.push_back({random_letters(4,24), random_int(1'000'000)});
    return res;
}
```

----------------------------------------------------------------

Declarations and definitions (선언과 정의)
<br>
선언(declaration)이란 이름(name)을 특정 범위(scope)에 도입하는 문(statement)이다. 
<br>
선언되지 않은 식별자(undeclared identifier). 
<br>
완전히 정의된 선언(declaration)은 정의(definition).
<br>
<br>
___C++가 선언(declaration)과 정의(definition)를 모두 제공하는 이유는 무엇인가?___
<br>
선언과 정의의 구분은 어떤 대상을 “사용하기 위해 필요한 것”(인터페이스, interface)과 
그 대상이 “실제로 동작하기 위해 필요한 것”(구현, implementation) 사이의 근본적인 차이를 반영한다. 
변수의 경우, 선언은 타입(type)을 제공하지만, 정의만이 객체(즉, 메모리)를 제공한다. 
함수의 경우에도 선언은 타입(인자 타입과 반환 타입)을 제공하지만, 정의만이 함수 본문(실행 가능한 문장들)을 제공한다.
<br>
함수 본문은 프로그램의 일부로서 메모리에 저장되므로, 함수 및 변수의 정의는 메모리를 소비한다고 말할 수 있다. 
반면, 선언은 메모리를 소비하지 않는다. 
이러한 선언/정의의 구분은 프로그램을 여러 부분으로 나누어 별도로 컴파일할 수 있도록 해준다. 
선언은 프로그램의 각 부분이 다른 부분의 정의를 알 필요 없이 전체 프로그램의 구조를 유지할 수 있게 한다. 
모든 선언(정의 포함)은 일관되어야 하므로, 프로그램 전체에서 이름의 사용은 일관성을 유지하게 된다. 
<br>
전방 선언(forward declaration)
<br>
순환 호출(cyclic call chain)
<br>
<br>
__Kinds of declarations (선언의 종류)__
<br>
변수 및 상수 (Variables and constants),
함수 (Functions),
네임스페이스 (Namespaces),
모듈 (Modules),
타입 (클래스 및 열거형; Types: classes and enumerations),
템플릿 (Templates),
콘셉트 (Concepts)
<br>
Variable and constant declarations (변수 및 상수 선언): 
변수 또는 상수의 선언은 이름(name), 타입(type), 그리고 선택적으로 초기화자(initializer)를 지정한다.
<br>
상수(constant)는 변수와 동일한 선언 문법을 사용하지만, 
타입에 const 또는 constexpr이 포함되며 반드시 초기화자가 필요하다 
<br>
함수 중첩은 C++에서 허용되지 않는다. 대신 람다(lambda)를 사용하라! {함수 및 블록 내부의 블록: 중첩 블록(nested block)
}
<br>
Pass-by-value (값에 의한 전달) : 함수에 인자를 전달하는 가장 단순한 방법은, 
인자로 사용된 값의 복사본을 함수에 넘겨주는 것이다. 
함수가 전달받은 인자의 복사본을 사용하므로, 원래의 변수는 함수 내부에서 변경되지 않는다. 
이는 함수가 외부 상태를 변경하지 않고 독립적으로 동작하도록 보장하는 데 유용하다.
<br>
<br>
참조(reference) : 자문해야 할 질문은 다음과 같다: “우리는 왜 복사를 하고 있는가?” 
우리는 단지 벡터를 출력하고 싶었을 뿐, 그 요소들을 복사하고 싶었던 것은 아니다.
당연히, 복사 없이 변수를 함수에 전달할 수 있는 방법이 있어야 한다. 비유하자면, 
도서관의 책 목록을 작성하는 과제를 받았다고 할 때, 사서가 도서관 건물과 모든 책을 복사해서 보내는 대신, 
도서관의 주소를 알려줄 것이다. 우리는 그 주소를 통해 직접 책을 확인할 수 있다.
따라서 print() 함수에 벡터의 복사본이 아니라 “주소”를 전달할 수 있는 방법이 필요하다. 
이러한 “주소”는 참조(reference)라고 한다.
<br>
<br>
값에 의한 전달(pass-by-value), 
<br>
참조에 의한 전달(pass-by-reference), 
<br>
const 참조에 의한 전달(pass-by-const-reference)은 언제 사용해야 할까? 
<br>
전달된 객체의 값을 변경하고 싶다면, 반드시 const가 아닌 참조(non-const reference)를 사용해야 한다. 
값 전달(pass-by-value)은 복사본을 제공하며, const 참조(pass-by-const-reference)는 전달된 객체의 값을 
변경하지 못하게 한다.
<br>
다음은 실용적인 규칙이다:
<br>
매우 작은 객체는 값에 의한 전달(pass-by-value)을 사용하라.
<br>
수정이 필요 없는 큰 객체는 const 참조에 의한 전달(pass-by-const-reference)을 사용하라.
<br>
객체를 참조 인자로 수정하기보다는 결과를 반환하라.
<br>
참조에 의한 전달(pass-by-reference)은 꼭 필요할 때만 사용하라.
<br>
<br>
<br>
<br>
<br>
<br>


----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------



