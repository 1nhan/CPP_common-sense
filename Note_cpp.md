----------------------------------------------------------------

# C5 Writing programming

의사코드(pseudo code) : 
설계 초기에 표기법의 정확한 의미가 아직 확실하지 않을 때 의사코드를 사용하곤 한다.

```text
while (not_finished) {
    read_a_line
    calculate // 처리 수행
    write_result
}
```
----------------------------------------------------------------


[토큰(token)](https://learn.microsoft.com/ko-kr/cpp/cpp/character-sets?view=msvc-170) : 은 숫자나 연산자처럼 우리가 한 단위(unit)로 간주하는 문자들의 연속이다. 
어떤 형태로든 “토큰화”는 텍스트 분석(text analysis)이 시작되는 일반적인 방식이다.
토큰을 (kind,value) 쌍으로 나타내는 것

----------------------------------------------------------------

멤버 접근 표기(member access notation, 멤버 접근 표기)는 다음과 같다: 
object_name.member_name

----------------------------------------------------------------

토큰(Token)은 C++ 사용자 정의 타입(user-defined type)의 예이다. 
사용자 정의 타입은 데이터 멤버(data members)뿐만 아니라 
멤버 함수(member functions, operations)를 가질 수 있다.

----------------------------------------------------------------

토큰(Token)을 초기화(construct)할 수 있다. 예를 들면:

```cpp
Token t1 {'+'};         // t1.kind = '+'
Token t2 {'8', 11.5};   // t2.kind = '8'이고 t2.value = 11.5
Token t3;               // 오류: 초기자(initializer) 누락
```

----------------------------------------------------------------
토큰 사용하기(Using tokens)

```cpp
Token get_token();
vector <Token>tok;

int main(void)
{
    while(cin)
    {
        Token t = get_token();
        tok.push_back(t);_
    }

return 0;
}
```

----------------------------------------------------------------

곱셈 연산 찾기(Finding multiply)

```cpp

for(int i =0; i<tok.size(); ++i){
    if(tok[i].kind=="*"){   
    double d = tok[i-1].value*tok[i+1].value};
    }
}
```
----------------------------------------------------------------

초기에는 기능 확장(feature creep)을 피하고 필수 기능만 구현한 단순한 버전을 먼저 만드는 것이 중요하다. 

----------------------------------------------------------------


문법에 따라 토큰의 흐름을 읽는 것을 파싱(parsing)이라 하며, 
이를 수행하는 프로그램은 일반적으로 파서(parser) 
                            또는 구문 분석기(syntax analyzer)라 불린다. 
문법을 표현하고 이에 대한 파서를 작성하는 방법에 관한 전문 서적도 존재하며, 
문법으로부터 파서를 생성하는 파서 생성기(parser generator)라는 프로그램도 있다.

----------------------------------------------------------------

문법을 어떻게 읽을까? 
기본적으로 어떤 입력이 주어지면, 
우리는 “최상위 규칙(top rule)”인 Expression부터 시작하여, 
읽은 토큰에 맞는 규칙을 찾아간다. 
이러한 전략을 상향식(top-down) 접근이라 한다. 
<br>
반대로, 먼저 토큰을 보고 어떤 문법 규칙이 적용될 수 있을지를 판단한 뒤, 
다음 토큰을 확인하면서 가능한 규칙을 좁혀가는 방식도 있다. 
이는 하향식(bottom-up) 접근이라 한다.

----------------------------------------------------------------

재귀(recursion)란 함수가 자기 자신을 호출하는 것을 의미한다. 
모든 재귀가 무한인 것은 아니며, 재귀는 매우 유용한 프로그래밍 기법이다

----------------------------------------------------------------

[switch 명령문](https://learn.microsoft.com/ko-kr/cpp/cpp/switch-statement-cpp?view=msvc-170 "switch 문") 본문은 일련의 case 레이블과 선택적 default 레이블로 구성됩니다.
default 레이블은 한 번만 나타날 수 있습니다. 
default 문은 종종 끝에 배치되지만 switch 문 본문의 아무 곳에나 나타날 수 있습니다. 
case 또는 default 레이블은 switch 문 안에만 나타날 수 있습니다.


----------------------------------------------------------------

#### 오류
&nbsp;↳컴파일 타임 오류(Compile-time errors) <br>
&emsp;↳ 문법 오류(Syntax errors) <br>
&emsp;↳ 타입 오류(Type errors) <br>
&nbsp;↳링크 타임 오류(Link-time errors) <br>
&nbsp;↳런타임 오류(Run-time errors)  <br>
&emsp;↳ 컴퓨터(하드웨어 또는 운영체제)가 감지한 오류 <br>
&emsp;↳ 라이브러리(예: 표준 라이브러리)가 감지한 오류 <br>
&emsp;↳ 사용자 코드가 감지한 오류 = 논리 오류(Logic errors) <br>

----------------------------------------------------------------

컴파일 타임 오류(Compile-time errors) : 코드를 실제로 생성하기 전에, 
컴파일러는 코드를 분석하여 문법 오류(syntax errors)와 타입 오류(type errors)를 감지합니다.
프로그램이 언어 명세(language specification)를 충족한다고 판단될 때에만 
컴파일러는 다음 단계로 진행을 허용합니다.<br>

문법 오류(syntax error) : C++ 문법에 따라 올바르게 작성되지 않았기 때문에, 
컴파일러는 이를 거부(reject)합니다. 대개 사소한 실수임에도 불구하고, 
컴파일러의 오류 메시지는 난해하고(cryptic) 때로는 프로그램의 다른 줄을 참조하기도 합니다.<br>

타입 오류(type error) : 변수나 함수 등에 대해 선언한 타입(또는 선언하지 않은 경우)과 
그에 대해 대입하거나 함수 인자로 전달하는 값의 타입이 일치하지 않을 때 발생합니다.<br>


링크 타임 오류(Link-time errors) : <br>
모든 함수는 다음 두 가지 규칙을 반드시 따라야 합니다:<br>
 1. 프로그램 내에서 사용되는 모든 변환 단위에서 해당 함수는 정확히 동일한 타입(type)으로 
선언(declaration)되어야 합니다.<br>
 2. 해당 함수는 프로그램 전체에서 정확히 한 번만 정의(definition)되어야 합니다.<br>
이 중 하나라도 위반되면, 링커(linker)는 오류를 발생시킵니다.<br>

런타임 오류(Run-time errors) : <br>
프로그램의 논리적 구조에 대한 이해가 부족했거나<br>
여러분이 작성했다고 생각한 코드가 실제로는 다르게 작성되었거나<br>
if 문 등에서 사소한 실수(silly error)를 저질렀거나<br>
이러한 논리 오류(logic error)는 대개 가장 찾기 어렵고 제거하기 까다로운 오류입니다.


----------------------------------------------------------------

프로그램에서 발생할 수 있는 오류의 주요 원천<br>
&emsp;&emsp;↳ 부정확하거나 부실한 사양, 명세(Poor specification)<br>
&emsp;&emsp;↳ 불완전한 프로그램(Incomplete programs)<br>
&emsp;&emsp;↳ 예상치 못한 인자(Unexpected arguments)<br>
&emsp;&emsp;↳ 예상치 못한 입력(Unexpected input)<br>
&emsp;&emsp;↳ 예상치 못한 상태(Unexpected state)<br>
&emsp;&emsp;↳ 논리 오류(Logical errors)

----------------------------------------------------------------

피호출자 검사(callee checks):<br>
“함수 자체가 인자를 검사해야 한다”는 방식, 
호출된 함수(called function)를 피호출자(callee)라고 부르기 때문입니다.<br>

----------------------------------------------------------------

___함수 내부에서 인자 검사가 항상 좋은가?___<br>
___함수 내부에서 인자를 검사하는 것이 이렇게 간단한데, 왜 모든 사람이 항상 그렇게 하지 않을까요?___<br>

__1. 함수 정의를 수정할 수 없는 경우__<br>
해당 함수가 라이브러리 함수일 수 있음<br>
다른 사용자들이 오류 처리 기준을 공유하지 않을 수 있음<br>
소스 코드가 없거나, 라이브러리가 자주 업데이트되므로, 수정한 내용을 매번 다시 적용해야 하는 부담이 있음<br>
__2. 피호출자가 오류 발생 시 무엇을 해야 할지 모르는 경우__<br>
특히 라이브러리 함수에서 흔한 상황<br>
라이브러리 작성자는 오류를 감지할 수 있지만, 오류 발생 시 어떤 행동을 취해야 하는지는 호출자만 알고 있음<br>
__3. 피호출자가 어디서 호출되었는지 모르는 경우__<br>
오류 메시지는 문제가 발생했음을 알려줄 뿐, 어떻게 그 지점에 도달했는지는 알려주지 않음<br>
때로는 더 구체적인 오류 메시지가 필요함<br>
__4. 성능 문제(Performance)__<br>
작은 함수에서는 검사 비용이 계산 비용보다 클 수 있음<br>
예: area() 함수의 경우 검사 코드가 함수의 크기를 두 배 이상 증가시킴 즉, 
실행해야 할 기계 명령어(machine instructions)의 수가 늘어남<br>
특히 함수들이 서로 호출하며 같은 정보를 반복적으로 검사하는 경우 성능에 치명적일 수 있음<br><br>
___결론: 특별한 이유가 없다면, 함수 내부에서 인자 검사를 수행하라.___<br>

----------------------------------------------------------------

인자(argument)를 검사한 결과 오류가 발견되었다면, 그 다음엔 무엇을 해야 할까?<br>
“오류 값(error value)”을 반환하는 방식<br>

----------------------------------------------------------------

___예외 처리의 핵심 아이디어___<br>
오류의 감지(detection)는 피호출자(called function)가 수행하고,<br>
오류의 처리(handling)는 호출자(calling function)가 수행하며,<br>
감지된 오류가 무시되지 않도록 보장하는 것<br><br>
>기본 개념<br>
> 함수가 처리할 수 없는 오류를 발견했을 때, 또는 즉시 상위 호출자가 처리할 수 있을 것이라 
기대할 수 없을 때, 해당 함수는 정상적으로 반환하지 않고,  예외를 던진다.(throw)<br>
> 예외는 무엇이 잘못되었는지를 나타내는 정보를 포함합니다. 
예외를 던진 함수의 직접 또는 간접 호출자(caller)는 해당 예외를 잡을 수 있다.(catch)<br>
> 즉, 예외가 발생했을 때 어떤 동작을 할지 지정할 수 있다.<br>
> 함수가 예외에 관심을 표현하려면 try 블록(try-block)을 사용해야 하며, 
그 안에 catch 블록(catch part)을 통해 처리하고자 하는 예외의 종류를 명시합니다.<br>
> 만약 어떤 호출자도 예외를 잡지 않으면, 프로그램은 비정상적으로 종료(terminate)됩니다.

----------------------------------------------------------------

___오류 출력: cerr 사용___<br>
오류 메시지 출력에는 cout 대신 cerr를 사용합니다.<br>
cerr는 cout과 동일하게 화면에 출력되지만 오류 출력용으로 설계되어 
더 견고하고(error-resilient) 일부 운영체제에서는 파일 등 다른 대상으로 
리디렉션 가능합니다.<br>
cerr를 사용하면 해당 출력이 오류 관련임을 명확히 문서화할 수 있습니다.

----------------------------------------------------------------

C++에서 흔히 사용하는 범위 표기법(range notation)

```코드
[low : high)
```
low 이상(high 미만)의 인덱스. 즉, low는 포함되고, high는 포함되지 않음

```cpp
i <= v.size()
```
이건 잘못된 조건입니다.  정확한 조건은 i < v.size()여야 합니다. 벡터의 끝을 초과한 접근(out-of-range access)입니다.
<br>
off-by-one error (1 차이 오류)<br>
range error (범위 오류)<br>
bounds error (경계 오류)<br>
모두 벡터의 유효한 인덱스 범위를 벗어난 접근을 의미합니다.

----------------------------------------------------------------

___디버깅(Debugging)___<br>
코드를 작성한 후에는 오류를 찾아내고 제거해야 합니다.
이 과정을 디버깅(debugging)이라 합니다.

디버깅의 핵심 질문<br>
___“내 프로그램이 실제로 제대로 작동하는지 어떻게 알 수 있을까?”___ <br>

___버그가 숨을 수 없도록 설계하라___<br>
디버깅은 코드를 작성하기 전에 이미 시작되어야 합니다. 
코드를 많이 작성한 뒤에 디버깅을 단순화하려고 하면 이미 늦습니다. 
먼저 오류를 어떻게 보고할지 결정하세요.

프로그램을 읽기 쉽게 만들기<br>
주석(Comment)을 잘 작성하세요.<br>
의미 있는 이름을 사용하세요.<br>
일관된 코드 레이아웃을 유지하세요. <br>
코드를 작은 함수로 나누세요. <br>
복잡한 코드 구조를 피하세요.<br>
라이브러리를 적극 활용하세요. <br>
컴파일부터 시작하세요. <br>
불변 조건(invariant)을 검사하세요.(단언문(assertion))<br>

----------------------------------------------------------------

___사전 조건이란?___<br>
함수가 인자에 대해 요구하는 조건을 사전 조건(precondition)이라고 합니다. 
이 조건이 참이어야만 함수가 정상적으로 동작할 수 있습니다.<br>

사전 조건이 위반되었을 때 어떻게 할 것인가?<br>
기본적으로 선택지는 두 가지입니다:<br>
무시한다. → 모든 호출자가 올바른 인자를 줄 것이라 가정하거나 희망한다<br>
검사한다. → 조건을 확인하고, 오류를 보고한다

----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------



