----------------------------------------------------------------

# C5 Writing programming

의사코드(pseudo code) : 
설계 초기에 표기법의 정확한 의미가 아직 확실하지 않을 때 의사코드를 사용하곤 한다.

```text
while (not_finished) {
    read_a_line
    calculate // 처리 수행
    write_result
}
```
----------------------------------------------------------------


[토큰(token)](https://learn.microsoft.com/ko-kr/cpp/cpp/character-sets?view=msvc-170) : 은 숫자나 연산자처럼 우리가 한 단위(unit)로 간주하는 문자들의 연속이다. 
어떤 형태로든 “토큰화”는 텍스트 분석(text analysis)이 시작되는 일반적인 방식이다.
토큰을 (kind,value) 쌍으로 나타내는 것

----------------------------------------------------------------

멤버 접근 표기(member access notation, 멤버 접근 표기)는 다음과 같다: 
object_name.member_name

----------------------------------------------------------------

토큰(Token)은 C++ 사용자 정의 타입(user-defined type)의 예이다. 
사용자 정의 타입은 데이터 멤버(data members)뿐만 아니라 
멤버 함수(member functions, operations)를 가질 수 있다.

----------------------------------------------------------------

토큰(Token)을 초기화(construct)할 수 있다. 예를 들면:

```cpp
Token t1 {'+'};         // t1.kind = '+'
Token t2 {'8', 11.5};   // t2.kind = '8'이고 t2.value = 11.5
Token t3;               // 오류: 초기자(initializer) 누락
```

----------------------------------------------------------------
토큰 사용하기(Using tokens)

```cpp
Token get_token();
vector <Token>tok;

int main(void)
{
    while(cin)
    {
        Token t = get_token();
        tok.push_back(t);_
    }

return 0;
}
```

----------------------------------------------------------------

곱셈 연산 찾기(Finding multiply)

```cpp

for(int i =0; i<tok.size(); ++i){
    if(tok[i].kind=="*"){   
    double d = tok[i-1].value*tok[i+1].value};
    }
}
```
----------------------------------------------------------------

초기에는 기능 확장(feature creep)을 피하고 필수 기능만 구현한 단순한 버전을 먼저 만드는 것이 중요하다. 

----------------------------------------------------------------


문법에 따라 토큰의 흐름을 읽는 것을 파싱(parsing)이라 하며, 
이를 수행하는 프로그램은 일반적으로 파서(parser) 
                            또는 구문 분석기(syntax analyzer)라 불린다. 
문법을 표현하고 이에 대한 파서를 작성하는 방법에 관한 전문 서적도 존재하며, 
문법으로부터 파서를 생성하는 파서 생성기(parser generator)라는 프로그램도 있다.

----------------------------------------------------------------

문법을 어떻게 읽을까? 
기본적으로 어떤 입력이 주어지면, 
우리는 “최상위 규칙(top rule)”인 Expression부터 시작하여, 
읽은 토큰에 맞는 규칙을 찾아간다. 
이러한 전략을 상향식(top-down) 접근이라 한다. 
<br>
반대로, 먼저 토큰을 보고 어떤 문법 규칙이 적용될 수 있을지를 판단한 뒤, 
다음 토큰을 확인하면서 가능한 규칙을 좁혀가는 방식도 있다. 
이는 하향식(bottom-up) 접근이라 한다.

----------------------------------------------------------------

재귀(recursion)란 함수가 자기 자신을 호출하는 것을 의미한다. 
모든 재귀가 무한인 것은 아니며, 재귀는 매우 유용한 프로그래밍 기법이다

----------------------------------------------------------------

[switch 명령문](https://learn.microsoft.com/ko-kr/cpp/cpp/switch-statement-cpp?view=msvc-170 "switch 문") 본문은 일련의 case 레이블과 선택적 default 레이블로 구성됩니다.
default 레이블은 한 번만 나타날 수 있습니다. 
default 문은 종종 끝에 배치되지만 switch 문 본문의 아무 곳에나 나타날 수 있습니다. 
case 또는 default 레이블은 switch 문 안에만 나타날 수 있습니다.


----------------------------------------------------------------

#### 오류
&nbsp;↳컴파일 타임 오류(Compile-time errors) <br>
&emsp;↳ 문법 오류(Syntax errors) <br>
&emsp;↳ 타입 오류(Type errors) <br>
&nbsp;↳링크 타임 오류(Link-time errors) <br>
&nbsp;↳런타임 오류(Run-time errors)  <br>
&emsp;↳ 컴퓨터(하드웨어 또는 운영체제)가 감지한 오류 <br>
&emsp;↳ 라이브러리(예: 표준 라이브러리)가 감지한 오류 <br>
&emsp;↳ 사용자 코드가 감지한 오류 = 논리 오류(Logic errors) <br>

----------------------------------------------------------------

컴파일 타임 오류(Compile-time errors) : 코드를 실제로 생성하기 전에, 
컴파일러는 코드를 분석하여 문법 오류(syntax errors)와 타입 오류(type errors)를 감지합니다.
프로그램이 언어 명세(language specification)를 충족한다고 판단될 때에만 
컴파일러는 다음 단계로 진행을 허용합니다.<br>

문법 오류(syntax error) : C++ 문법에 따라 올바르게 작성되지 않았기 때문에, 
컴파일러는 이를 거부(reject)합니다. 대개 사소한 실수임에도 불구하고, 
컴파일러의 오류 메시지는 난해하고(cryptic) 때로는 프로그램의 다른 줄을 참조하기도 합니다.<br>

타입 오류(type error) : 변수나 함수 등에 대해 선언한 타입(또는 선언하지 않은 경우)과 
그에 대해 대입하거나 함수 인자로 전달하는 값의 타입이 일치하지 않을 때 발생합니다.<br>


링크 타임 오류(Link-time errors) : <br>
모든 함수는 다음 두 가지 규칙을 반드시 따라야 합니다:<br>
 1. 프로그램 내에서 사용되는 모든 변환 단위에서 해당 함수는 정확히 동일한 타입(type)으로 
선언(declaration)되어야 합니다.<br>
 2. 해당 함수는 프로그램 전체에서 정확히 한 번만 정의(definition)되어야 합니다.<br>
이 중 하나라도 위반되면, 링커(linker)는 오류를 발생시킵니다.<br>

런타임 오류(Run-time errors) : <br>
프로그램의 논리적 구조에 대한 이해가 부족했거나<br>
여러분이 작성했다고 생각한 코드가 실제로는 다르게 작성되었거나<br>
if 문 등에서 사소한 실수(silly error)를 저질렀거나<br>
이러한 논리 오류(logic error)는 대개 가장 찾기 어렵고 제거하기 까다로운 오류입니다.


----------------------------------------------------------------

프로그램에서 발생할 수 있는 오류의 주요 원천<br>
&emsp;&emsp;↳ 부정확하거나 부실한 사양, 명세(Poor specification)<br>
&emsp;&emsp;↳ 불완전한 프로그램(Incomplete programs)<br>
&emsp;&emsp;↳ 예상치 못한 인자(Unexpected arguments)<br>
&emsp;&emsp;↳ 예상치 못한 입력(Unexpected input)<br>
&emsp;&emsp;↳ 예상치 못한 상태(Unexpected state)<br>
&emsp;&emsp;↳ 논리 오류(Logical errors)

----------------------------------------------------------------

피호출자 검사(callee checks):<br>
“함수 자체가 인자를 검사해야 한다”는 방식, 
호출된 함수(called function)를 피호출자(callee)라고 부르기 때문입니다.<br>

----------------------------------------------------------------

___함수 내부에서 인자 검사가 항상 좋은가?___<br>
___함수 내부에서 인자를 검사하는 것이 이렇게 간단한데, 왜 모든 사람이 항상 그렇게 하지 않을까요?___<br>

__1. 함수 정의를 수정할 수 없는 경우__<br>
해당 함수가 라이브러리 함수일 수 있음<br>
다른 사용자들이 오류 처리 기준을 공유하지 않을 수 있음<br>
소스 코드가 없거나, 라이브러리가 자주 업데이트되므로, 수정한 내용을 매번 다시 적용해야 하는 부담이 있음<br>
__2. 피호출자가 오류 발생 시 무엇을 해야 할지 모르는 경우__<br>
특히 라이브러리 함수에서 흔한 상황<br>
라이브러리 작성자는 오류를 감지할 수 있지만, 오류 발생 시 어떤 행동을 취해야 하는지는 호출자만 알고 있음<br>
__3. 피호출자가 어디서 호출되었는지 모르는 경우__<br>
오류 메시지는 문제가 발생했음을 알려줄 뿐, 어떻게 그 지점에 도달했는지는 알려주지 않음<br>
때로는 더 구체적인 오류 메시지가 필요함<br>
__4. 성능 문제(Performance)__<br>
작은 함수에서는 검사 비용이 계산 비용보다 클 수 있음<br>
예: area() 함수의 경우 검사 코드가 함수의 크기를 두 배 이상 증가시킴 즉, 
실행해야 할 기계 명령어(machine instructions)의 수가 늘어남<br>
특히 함수들이 서로 호출하며 같은 정보를 반복적으로 검사하는 경우 성능에 치명적일 수 있음<br><br>
___결론: 특별한 이유가 없다면, 함수 내부에서 인자 검사를 수행하라.___<br>

----------------------------------------------------------------

인자(argument)를 검사한 결과 오류가 발견되었다면, 그 다음엔 무엇을 해야 할까?
“오류 값(error value)”을 반환하는 방식

----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------



